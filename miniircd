#! /usr/bin/env python
# Hey, Emacs! This is -*-python-*-.
#
# Copyright (C) 2003-2015 Joel Rosdahl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#
# Joel Rosdahl <joel@rosdahl.net>

VERSION = "1.0"

import os
import re
import select
import socket
import string
import sys
import tempfile
import time
from datetime import datetime
from optparse import OptionParser
import datetime
import threading
import Queue
import signal
from flow.flow_api import Flow


def create_directory(path):
    if not os.path.isdir(path):
        os.makedirs(path)


def get_message_timestamp_string(timestamp_usecs):
    timestamp_secs = timestamp_usecs / 1.0e+6
    return datetime.datetime.fromtimestamp(timestamp_secs).strftime("[%Y-%m-%d %H:%M:%S]")


class ChannelMember(object):
    def __init__(self, nickname, account_id):
        self.nickname = nickname
        self.account_id = account_id
        self.user = ""
        self.host = ""
        self.realname = ""


class Channel(object):
    def __init__(self, gateway, name):
        self.gateway = gateway
        self.name = name
        self.members = set() # set of "ChannelMember"
        self._topic = ""
        self._key = None
        self.organization_id = ""
        self.channel_id = ""

    def get_member_from_account_id(self, account_id):
        for member in self.members:
            if member.account_id == account_id:
                return member
        return None

    def get_member_from_nickname(self, nickname):
        for member in self.members:
            if member.nickname == nickname:
                return member
        return None

    def add_member(self, client):
        self.members.add(client)

    def get_topic(self):
        return self._topic

    def set_topic(self, value):
        self._topic = value

    topic = property(get_topic, set_topic)

    def get_key(self):
        return self._key

    def set_key(self, value):
        self._key = value

    key = property(get_key, set_key)

    def remove_client(self, client):
        self.members.discard(client)
        if not self.members:
            self.gateway.remove_channel(self)


class IRCClient(object):
    __linesep_regexp = re.compile(r"\r?\n")
    # The RFC limit for nicknames is 9 characters, but what the heck.
    __valid_nickname_regexp = re.compile(
        r"^[][\`_^{|}A-Za-z][][\`_^{|}A-Za-z0-9-]{0,50}$")
    __valid_channelname_regexp = re.compile(
        r"^[&#+!][^\x00\x07\x0a\x0d ,:]{0,50}$")

    def __init__(self, gateway, socket):
        self.gateway = gateway
        self.socket = socket
        self.nickname = None
        self.user = None
        self.realname = None
        self.channels = {} # # irc_lower(Channel name) --> Channel instance.
        (self.host, self.port) = socket.getpeername()
        self.__timestamp = time.time()
        self.__readbuffer = ""
        self.__writebuffer = ""
        self.__sent_ping = False
        self.__handle_command = self.__registration_handler

    def get_prefix(self):
        return "%s!%s@%s" % (self.nickname, self.user, self.host)
    prefix = property(get_prefix)

    def check_aliveness(self):
        now = time.time()
        if self.__timestamp + 180 < now:
            self.disconnect("ping timeout")
            return
        if not self.__sent_ping and self.__timestamp + 90 < now:
            if self.__handle_command == self.__command_handler:
                # Registered.
                self.message("PING :%s" % self.gateway.name)
                self.__sent_ping = True
            else:
                # Not registered.
                self.disconnect("ping timeout")

    def write_queue_size(self):
        return len(self.__writebuffer)

    def __parse_read_buffer(self):
        lines = self.__linesep_regexp.split(self.__readbuffer)
        self.__readbuffer = lines[-1]
        lines = lines[:-1]
        for line in lines:
            if not line:
                # Empty line. Ignore.
                continue
            x = line.split(" ", 1)
            command = x[0].upper()
            if len(x) == 1:
                arguments = []
            else:
                if len(x[1]) > 0 and x[1][0] == ":":
                    arguments = [x[1][1:]]
                else:
                    y = string.split(x[1], " :", 1)
                    arguments = string.split(y[0])
                    if len(y) == 2:
                        arguments.append(y[1])
            self.__handle_command(command, arguments)

    def __pass_handler(self, command, arguments):
        gateway = self.gateway
        if command == "PASS":
            if len(arguments) == 0:
                self.reply_461("PASS")
        elif command == "QUIT":
            self.disconnect("Client quit")
        return

    def __registration_handler(self, command, arguments):
        gateway = self.gateway
        if command == "NICK":
            if len(arguments) < 1:
                self.reply("431 :No nickname given")
                return
            nick = arguments[0]
            if gateway.get_client(nick):
                self.reply("433 * %s :Nickname is already in use" % nick)
            elif not self.__valid_nickname_regexp.match(nick):
                self.reply("432 * %s :Erroneous nickname" % nick)
            else:
                self.nickname = nick
                gateway.client_changed_nickname(self, None)
        elif command == "USER":
            if len(arguments) < 4:
                self.reply_461("USER")
                return
            self.user = arguments[0]
            self.realname = arguments[3]
        elif command == "QUIT":
            self.disconnect("Client quit")
            return
        if self.nickname and self.user:
            self.reply("001 %s :Hi, welcome to IRC" % self.nickname)
            self.reply("002 %s :Your host is %s, running version irc-flow-gateway-%s"
                       % (self.nickname, gateway.name, VERSION))
            self.reply("003 %s :This gateway was created sometime"
                       % self.nickname)
            self.reply("004 %s :%s irc-flow-gateway-%s o o"
                       % (self.nickname, gateway.name, VERSION))
            self.send_lusers()
            self.send_motd()
            self.send_channels_data()
            self.__handle_command = self.__command_handler

    def __command_handler(self, command, arguments):
        def away_handler():
            pass

        def ison_handler():
            pass

        def join_handler():
            pass

        def list_handler():
            if len(arguments) < 1:
                channels = gateway.channels.values()
            else:
                channels = []
                for channelname in arguments[0].split(","):
                    if gateway.has_channel(channelname):
                        channels.append(gateway.get_channel(channelname))
            channels.sort(key=lambda x: x.name)
            for channel in channels:
                self.reply("322 %s %s %d :%s"
                           % (self.nickname, channel.name,
                              len(channel.members), channel.topic))
            self.reply("323 %s :End of LIST" % self.nickname)

        def lusers_handler():
            self.send_lusers()

        def mode_handler():
            if len(arguments) < 1:
                self.reply_461("MODE")
                return
            targetname = arguments[0]
            if gateway.has_channel(targetname):
                channel = gateway.get_channel(targetname)
                if len(arguments) < 2:
                    if channel.key:
                        modes = "+k"
                        if irc_lower(channel.name) in self.channels:
                            modes += " %s" % channel.key
                    else:
                        modes = "+"
                    self.reply("324 %s %s %s"
                               % (self.nickname, targetname, modes))
                    return
                flag = arguments[1]
                if flag == "+k":
                    if len(arguments) < 3:
                        self.reply_461("MODE")
                        return
                    key = arguments[2]
                    if irc_lower(channel.name) in self.channels:
                        channel.key = key
                    else:
                        self.reply("442 %s :You're not on that channel"
                                   % targetname)
                elif flag == "-k":
                    if irc_lower(channel.name) in self.channels:
                        channel.key = None
                    else:
                        self.reply("442 %s :You're not on that channel"
                                   % targetname)
                else:
                    self.reply("472 %s %s :Unknown MODE flag"
                               % (self.nickname, flag))
            elif targetname == self.nickname:
                if len(arguments) == 1:
                    self.reply("221 %s +" % self.nickname)
                else:
                    self.reply("501 %s :Unknown MODE flag" % self.nickname)
            else:
                self.reply_403(targetname)

        def motd_handler():
            self.send_motd()

        def nick_handler():
            if len(arguments) < 1:
                self.reply("431 :No nickname given")
                return
            newnick = arguments[0]
            client = gateway.get_client(newnick)
            if newnick == self.nickname:
                pass
            elif client and client is not self:
                self.reply("433 %s %s :Nickname is already in use"
                           % (self.nickname, newnick))
            elif not self.__valid_nickname_regexp.match(newnick):
                self.reply("432 %s %s :Erroneous Nickname"
                           % (self.nickname, newnick))
            else:
                oldnickname = self.nickname
                self.nickname = newnick
                gateway.client_changed_nickname(self, oldnickname)

        def notice_and_privmsg_handler():
            if len(arguments) == 0:
                self.reply("411 %s :No recipient given (%s)"
                           % (self.nickname, command))
                return
            if len(arguments) == 1:
                self.reply("412 %s :No text to send" % self.nickname)
                return
            targetname = arguments[0]
            message = arguments[1]
            if gateway.has_channel(targetname):
                channel = gateway.get_channel(targetname)
                if channel:
                    gateway.transmit_message_to_channel(channel, message)
            elif gateway.has_member(targetname):
                member = gateway.get_member(targetname)
                gateway.transmit_message_to_member(member, message)
            else:
                self.reply("401 %s %s :No such nick/channel"
                           % (self.nickname, targetname))

        def part_handler():
            pass

        def ping_handler():
            if len(arguments) < 1:
                self.reply("409 %s :No origin specified" % self.nickname)
                return
            self.reply("PONG %s :%s" % (gateway.name, arguments[0]))

        def pong_handler():
            pass

        def quit_handler():
            if len(arguments) < 1:
                quitmsg = self.nickname
            else:
                quitmsg = arguments[0]
            self.disconnect(quitmsg)

        def topic_handler():
            if len(arguments) < 1:
                self.reply_461("TOPIC")
                return
            channelname = arguments[0]
            channel = self.channels.get(irc_lower(channelname))
            if channel:
                if len(arguments) > 1:
                    newtopic = arguments[1]
                    channel.topic = newtopic
                else:
                    if channel.topic:
                        self.reply("332 %s %s :%s"
                                   % (self.nickname, channel.name,
                                      channel.topic))
                    else:
                        self.reply("331 %s %s :No topic is set"
                                   % (self.nickname, channel.name))
            else:
                self.reply("442 %s :You're not on that channel" % channelname)

        def who_handler():
            if len(arguments) < 1:
                return
            targetname = arguments[0]
            if gateway.has_channel(targetname):
                channel = gateway.get_channel(targetname)
                for member in channel.members:
                    self.reply("352 %s %s %s %s %s %s H :0 %s"
                               % (self.nickname, targetname, member.user,
                                  member.host, gateway.name, member.nickname,
                                  member.realname))
                self.reply("315 %s %s :End of WHO list"
                           % (self.nickname, targetname))

        def whois_handler():
            if len(arguments) < 1:
                return
            username = arguments[0]
            user = gateway.get_client(username)
            if user:
                self.reply("311 %s %s %s %s * :%s"
                           % (self.nickname, user.nickname, user.user,
                              user.host, user.realname))
                self.reply("312 %s %s %s :%s"
                           % (self.nickname, user.nickname, gateway.name,
                              gateway.name))
                self.reply("319 %s %s :%s"
                           % (self.nickname, user.nickname,
                              " ".join(user.channels)))
                self.reply("318 %s %s :End of WHOIS list"
                           % (self.nickname, user.nickname))
            else:
                self.reply("401 %s %s :No such nick"
                           % (self.nickname, username))

        handler_table = {
            "AWAY": away_handler,
            "ISON": ison_handler,
            "JOIN": join_handler,
            "LIST": list_handler,
            "LUSERS": lusers_handler,
            "MODE": mode_handler,
            "MOTD": motd_handler,
            "NICK": nick_handler,
            "NOTICE": notice_and_privmsg_handler,
            "PART": part_handler,
            "PING": ping_handler,
            "PONG": pong_handler,
            "PRIVMSG": notice_and_privmsg_handler,
            "QUIT": quit_handler,
            "TOPIC": topic_handler,
            "WHO": who_handler,
            "WHOIS": whois_handler,
        }
        gateway = self.gateway
        valid_channel_re = self.__valid_channelname_regexp
        try:
            handler_table[command]()
        except KeyError:
            self.reply("421 %s %s :Unknown command" % (self.nickname, command))

    def socket_readable_notification(self):
        try:
            data = self.socket.recv(2 ** 10)
            self.gateway.print_debug(
                "[%s:%d] -> %r" % (self.host, self.port, data))
            quitmsg = "EOT"
        except socket.error as x:
            data = ""
            quitmsg = x
        if data:
            self.__readbuffer += data
            self.__parse_read_buffer()
            self.__timestamp = time.time()
            self.__sent_ping = False
        else:
            self.disconnect(quitmsg)

    def socket_writable_notification(self):
        try:
            sent = self.socket.send(self.__writebuffer)
            self.gateway.print_debug(
                "[%s:%d] <- %r" % (
                    self.host, self.port, self.__writebuffer[:sent]))
            self.__writebuffer = self.__writebuffer[sent:]
        except socket.error as x:
            self.disconnect(x)

    def disconnect(self, quitmsg):
        self.message("ERROR :%s" % quitmsg)
        self.gateway.print_info(
            "Disconnected connection from %s:%s (%s)." % (
                self.host, self.port, quitmsg))
        self.socket.close()
        self.gateway.remove_client(self, quitmsg)

    def message(self, msg):
        self.__writebuffer += msg + "\r\n"

    def reply(self, msg):
        self.message(":%s %s" % (self.gateway.name, msg))

    def reply_403(self, channel):
        self.reply("403 %s %s :No such channel" % (self.nickname, channel))

    def reply_461(self, command):
        nickname = self.nickname or "*"
        self.reply("461 %s %s :Not enough parameters" % (nickname, command))

    def send_lusers(self):
        self.reply("251 %s :There are %d users and 0 services on 1 gateway"
                   % (self.nickname, len(self.gateway.clients)))

    def send_motd(self):
        self.reply("422 %s :MOTD File is missing" % self.nickname)

    def send_channel_messages(self, channel):
        messages = self.gateway.flow_service.EnumerateMessages(self.gateway.flow_sid, channel.organization_id, channel.channel_id)
        for message in reversed(messages):
            member = channel.get_member_from_account_id(message["SenderAccountID"])
            if member:
                message_text = message["Text"]
                if self.gateway.show_timestamps:
                    message_timestamp = get_message_timestamp_string(message["CreationTime"])
                    message_text = message_timestamp + " " + message_text
                self.message(":%s!%s@%s PRIVMSG %s :%s" % (member.nickname, member.user, member.host, channel.name, message_text))

    def send_channel_irc_commands(self, channel):
        self.message(":%s!%s@%s JOIN :%s" % (self.nickname, self.user, self.host, channel.name))
        for member in channel.members:
            self.channels[irc_lower(channel.name)] = channel
            self.message(":%s!%s@%s JOIN :%s" % (member.nickname, member.user, member.host, channel.name))

    def send_channels_data(self):
        for channel in self.gateway.channels.values():
            self.send_channel_irc_commands(channel)
            self.send_channel_messages(channel)


class IRCFlowGateway(object):
    def __init__(self, options):
        self.ports = options.ports
        self.verbose = options.verbose
        self.debug = options.debug
        self.logdir = options.logdir
        self.show_timestamps = options.show_timestamps

        if options.listen:
            self.address = socket.gethostbyname(options.listen)
        else:
            self.address = ""
        gateway_name_limit = 63  # From the RFC.
        self.name = socket.getfqdn(self.address)[:gateway_name_limit]

        self.channels = {}  # irc_lower(Channel name) --> Channel instance.
        self.clients = {}  # Socket --> Client instance.
        self.nicknames = {}  # irc_lower(Nickname) --> Client instance.
        if self.logdir:
            create_directory(self.logdir)

        self._initialize_flow_service(options)

    def terminate(self):
        self.set_listen_to_events(False)
        self.flow_service.Terminate()

    def set_listen_to_events(self, value=True):
        self.listen_to_events = value

    def get_member(self, nickname):
        for channel in self.channels:
            for member in channel.members:
                if member.nickname == nickname:
                    return member
        return None

    def transmit_message_to_channel(self, channel, message_text):
        try:
            self.flow_service.SendMessage(self.flow_sid, channel.organization_id, channel.channel_id, message_text)
        except:
            pass

    def _get_channel_from_id(self, channel_id):
        for channel in self.channels.values():
            if channel.channel_id == channel_id:
                return channel
        return None

    def _get_remote_channel_name(self, org_name, channel_name):
        return ("#" + channel_name + "(" + org_name + ")").encode('ascii')

    def _get_orgs_and_channels(self):
        orgs = self.flow_service.EnumerateOrgs(self.flow_sid)
        for org in orgs:
            oid = org["ID"]
            channels = self.flow_service.EnumerateChannels(self.flow_sid, oid)
            for channel in channels:
                irc_channel_name = self._get_remote_channel_name(org["Name"], channel["Name"])
                irc_channel = Channel(self, irc_channel_name)
                irc_channel.channel_id = channel["ID"]
                irc_channel.organization_id = oid
                self.channels[irc_lower(irc_channel_name)] = irc_channel
                members = self.flow_service.EnumerateChannelMembers(self.flow_sid, irc_channel.channel_id)
                for member in members:
                    if member["EmailAddress"] == self.flow_user_email:
                        self.flow_user_account_id = member["AccountID"]
                    channel_member = ChannelMember(member["EmailAddress"].encode('ascii'), member["AccountID"])
                    irc_channel.add_member(channel_member)
                    self.nicknames[irc_lower(channel_member.nickname)] = channel_member

    def _start_listener(self):
        self.event_queue = Queue.Queue()
        self.set_listen_to_events()
        self.listener_thread = threading.Thread(
            target=self.event_listener_loop, 
            args=(self.flow_service, self.flow_sid, self.event_queue)
            )
        self.listener_thread.start()

    def _initialize_flow_service(self, options):
        try:
            self.flow_service = Flow(options.flow_flowappglue, options.debug)
            self.flow_service.Config(
                options.flow_server,
                options.flow_port,
                options.flow_db,
                options.flow_schema)
            self.flow_user_email = options.flow_email
            self.flow_sid = self.flow_service.NewSession(options.flow_email, options.flow_uri)
            self.flow_service.StartUp(self.flow_sid)
            self._get_orgs_and_channels()
            self._start_listener()
            self.flow_initialized = True
        except Flow.FlowError as e:
            self.flow_initialized = False
            self.print_error("Flow Initialization: '%s'" % str(e))

    def daemonize(self):
        try:
            pid = os.fork()
            if pid > 0:
                sys.exit(0)
        except OSError:
            sys.exit(1)
        os.setsid()
        try:
            pid = os.fork()
            if pid > 0:
                self.print_info("PID: %d" % pid)
                sys.exit(0)
        except OSError:
            sys.exit(1)
        os.chdir("/")
        os.umask(0)
        dev_null = open("/dev/null", "r+")
        os.dup2(dev_null.fileno(), sys.stdout.fileno())
        os.dup2(dev_null.fileno(), sys.stderr.fileno())
        os.dup2(dev_null.fileno(), sys.stdin.fileno())

    def get_client(self, nickname):
        return self.nicknames.get(irc_lower(nickname))

    def has_member(self, nickname):
        for channel in self.channels:
            for member in channel.members.values():
                if member.nickname == nickname:
                    return True
        return False

    def has_channel(self, name):
        return irc_lower(name) in self.channels

    def get_channel(self, channelname):
        if irc_lower(channelname) in self.channels:
            channel = self.channels[irc_lower(channelname)]
        else:
            channel = Channel(self, channelname)
            self.channels[irc_lower(channelname)] = channel
        return channel

    def print_info(self, msg):
        if self.verbose:
            print(msg)
            sys.stdout.flush()

    def print_debug(self, msg):
        if self.debug:
            print(msg)
            sys.stdout.flush()

    def print_error(self, msg):
        sys.stderr.write("%s\n" % msg)

    def client_changed_nickname(self, client, oldnickname):
        if oldnickname:
            del self.nicknames[irc_lower(oldnickname)]
        self.nicknames[irc_lower(client.nickname)] = client

    def remove_member_from_channel(self, client, channelname):
        if irc_lower(channelname) in self.channels:
            channel = self.channels[irc_lower(channelname)]
            channel.remove_client(client)

    def remove_client(self, client, quitmsg):
        for x in client.channels.values():
            x.remove_client(client)
        if client.nickname \
                and irc_lower(client.nickname) in self.nicknames:
            del self.nicknames[irc_lower(client.nickname)]
        del self.clients[client.socket]

    def remove_channel(self, channel):
        del self.channels[irc_lower(channel.name)]

    def message_notification(self, messages_data):
        for message in messages_data:
            sender_account_id = message["SenderAccountID"]
            channel_id = message["ChannelID"]
            message_text = message["Text"]
            if self.show_timestamps:
                message_timestamp = get_message_timestamp_string(message["CreationTime"])
                message_text = message_timestamp + " " + message_text
            channel = self._get_channel_from_id(channel_id)
            if not channel:
                return
            member = channel.get_member_from_account_id(sender_account_id)
            for client in self.clients.values():
                client.message(":%s!%s@%s PRIVMSG %s :%s" % (member.nickname, member.user, member.host, channel.name, message_text))

    def channel_notification(self, channels_data):
        for channel_data in channels_data:
            channel = self._get_channel_from_id(channel_data["ID"])
            if channel:
                return
            new_channel = Channel(self, channel_data["Name"])
            new_channel.channel_id = channel_data["ID"]
            new_channel.organization_id = channel_data["OrgID"]
            self.channels[irc_lower(channel_data["Name"])] = new_channel

            for client in self.clients.values():
                client.message(":%s!%s@%s JOIN :%s" % (client.nickname, client.user, client.host, channel.name))

            members = self.flow_service.EnumerateChannelMembers(self.flow_sid, irc_channel.channel_id)
            for member in members:
                channel_member = ChannelMember(member["EmailAddress"].encode('ascii'), member["AccountID"])
                new_channel.add_member(channel_member)
                self.nicknames[irc_lower(channel_member.nickname)] = channel_member
                for client in self.clients.values():
                    client.message(":%s!%s@%s JOIN :%s" % (member.nickname, member.user, member.host, channel.name))

    def channel_member_notification(self, channel_ids):
        for channel_id in channel_ids:
            channel = self._get_channel_from_id(channel_id)
            if not channel:
                return
            members = self.flow_service.EnumerateChannelMembers(self.flow_sid, channel_id)
            for member in members:
                channel_member = channel.get_member_from_nickname(member["EmailAddress"])
                if not channel_member:
                    channel_member = ChannelMember(member["EmailAddress"].encode('ascii'), member["AccountID"])
                    self.nicknames[irc_lower(channel_member.nickname)] = channel_member
                    channel.add_member(channel_member)
                    for client in self.clients.values():
                        client.message(":%s!%s@%s JOIN :%s" % (channel_member.nickname, channel_member.user, channel_member.host, channel.name))

    __supported_notifications = [ "message" , "channel", "channel-member-event" ]

    def process_notifications_queue(self):
        event_handler = {
            "message" : self.message_notification,
            "channel" : self.channel_notification,
            "channel-member-event" : self.channel_member_notification,
        }
        while not self.event_queue.empty():
            event = self.event_queue.get()
            try:
                event_handler[event["Type"]](event["Data"])
            except KeyError:
                self.print_debug("Notification of type '%s' not supported." % event["Type"])

    def event_listener_loop(self, flow, sid, event_queue):
        while self.listen_to_events:
            try:
                change = flow.WaitForNotification(sid)
                if change and (change["Type"] in self.__supported_notifications):
                    event_queue.put(change)
            except Flow.FlowError:
                pass

    def start(self):
        if not self.flow_initialized:
            self.terminate()
            return
        gatewaysockets = []
        for port in self.ports:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind((self.address, port))
            except socket.error as e:
                self.print_error("Could not bind port %s: %s." % (port, e))
                sys.exit(1)
            s.listen(5)
            gatewaysockets.append(s)
            del s
            self.print_info("Listening on port %d." % port)
        last_aliveness_check = time.time()
        while True:
            (iwtd, owtd, ewtd) = select.select(
                gatewaysockets + [x.socket for x in self.clients.values()],
                [x.socket for x in self.clients.values()
                 if x.write_queue_size() > 0],
                [],
                10)
            for x in iwtd:
                if x in self.clients:
                    self.clients[x].socket_readable_notification()
                else:
                    (conn, addr) = x.accept()
                    try:
                        self.clients[conn] = IRCClient(self, conn)
                        self.print_info("Accepted connection from %s:%s." % (
                            addr[0], addr[1]))
                    except socket.error as e:
                        try:
                            conn.close()
                        except:
                            pass
            for x in owtd:
                if x in self.clients:  # client may have been disconnected
                    self.clients[x].socket_writable_notification()
            self.process_notifications_queue()
            now = time.time()
            if last_aliveness_check + 10 < now:
                for client in self.clients.values():
                    client.check_aliveness()
                last_aliveness_check = now


_maketrans = str.maketrans if sys.version_info[0] == 3 else string.maketrans
_ircstring_translation = _maketrans(
    string.ascii_lowercase.upper() + "[]\\^",
    string.ascii_lowercase + "{}|~")


def irc_lower(s):
    return string.translate(s, _ircstring_translation)


def main(argv):
    op = OptionParser(
        version=VERSION,
        description="irc-flow-gateway is a small IRC gateway to SpiderOak Flow (based on miniircd)")
    op.add_option(
        "-d", "--daemon",
        action="store_true",
        help="fork and become a daemon")
    op.add_option(
        "--debug",
        action="store_true",
        help="print debug messages to stdout")
    op.add_option(
        "--listen",
        metavar="X",
        help="listen on specific IP address X")
    op.add_option(
        "--logdir",
        metavar="X",
        help="store channel log in directory X")
    op.add_option(
        "--ports",
        metavar="X",
        help="listen to ports X (a list separated by comma or whitespace);"
             " default: 6667")
    op.add_option(
        "--verbose",
        action="store_true",
        help="be verbose (print some progress messages to stdout)")
    op.add_option(
        "--flow-flowappglue",
        metavar="X",
        help="flowappglue binary path (by default ./flowappglue)")
    op.add_option(
        "--flow-server",
        metavar="X",
        help="flow service host/ip")
    op.add_option(
        "--flow-port",
        metavar="X",
        help="flow service port")
    op.add_option(
        "--flow-db",
        metavar="X",
        help="flow db directory")
    op.add_option(
        "--flow-schema",
        metavar="X",
        help="flow schema directory")
    op.add_option(
        "--flow-email",
        metavar="X",
        help="flow account email")
    op.add_option(
        "--flow-uri",
        metavar="X",
        help="flow account gateway uri")
    op.add_option(
        "--show-timestamps",
        action="store_true",
        help="prepend timestamps on messages (format: [Y-m-d H:M:S])")

    (options, args) = op.parse_args(argv[1:])

    if not options.flow_server or \
       not options.flow_port or \
       not options.flow_db or \
       not options.flow_email or \
       not options.flow_uri:
        missing_arguments = []
        if not options.flow_server:
            missing_arguments.append("'--flow-server'")
        if not options.flow_port:
            missing_arguments.append("'--flow-port'")
        if not options.flow_db:
            missing_arguments.append("'--flow-db'")
        if not options.flow_email:
            missing_arguments.append("'--flow-email'")
        if not options.flow_uri:
            missing_arguments.append("'--flow-uri'")
        op.error("Missing arguments: %s" % ", ".join(missing_arguments))

    if not options.flow_flowappglue:
        options.flow_flowappglue = "./flowappglue"

    if options.debug:
        options.verbose = True
    if options.ports is None:
        options.ports = "6667"
    ports = []
    for port in re.split(r"[,\s]+", options.ports):
        try:
            ports.append(int(port))
        except ValueError:
            op.error("bad port: %r" % port)
    options.ports = ports
    gateway = IRCFlowGateway(options)

    def signal_handler(signal, frame):
        print(" ... terminating ...")
        gateway.terminate()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    if options.daemon:
        gateway.daemonize()

    gateway.start()


main(sys.argv)