#! /usr/bin/env python
# Hey, Emacs! This is -*-python-*-.
#
# Copyright (C) 2003-2015 Joel Rosdahl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#
# Joel Rosdahl <joel@rosdahl.net>

VERSION = "1.0"

import os
import re
import select
import socket
import string
import sys
import time
from datetime import datetime
from optparse import OptionParser
import threading
import Queue
import signal
from collections import namedtuple
from flow.flow_api import Flow


def get_message_timestamp_string(timestamp_usecs):
    timestamp_secs = timestamp_usecs / 1.0e+6
    return datetime.fromtimestamp(timestamp_secs).strftime("[%Y-%m-%d %H:%M:%S]")


def irc_escape(s):
    return s.replace(",", "-").replace(" ", "-")


ChannelMember = namedtuple(
    "ChannelMember", ["nickname", "account_id", "user", "host", "realname"])


class Channel(object):

    def __init__(self, gateway, channel_id, channel_name="", organization_id="", organization_name="", direct_channel=False, created_on_irc_session=False):
        self.gateway = gateway
        self.members = set()  # set of "ChannelMember"
        self.channel_id = channel_id
        self.set_name(channel_name)
        self.organization_id = organization_id
        self.set_organization_name(organization_name)
        self.direct_channel = direct_channel
        self.created_on_irc_session = created_on_irc_session

    def set_name(self, channel_name):
        self.channel_name = channel_name.encode('ascii')

    def set_organization_name(self, organization_name):
        self.organization_name = organization_name.encode('ascii')

    def get_other_member(self):
        if not self.direct_channel or len(self.members) != 2:
            return ""
        for member in self.members:
            if member.account_id != self.gateway.flow_account_id:
                return member.nickname
        return ""

    def get_irc_name(self):
        if self.direct_channel:
            if self.created_on_irc_session:
                return irc_escape(self.get_other_member())
            else:
                return "#" + irc_escape(self.get_other_member()) + "(" + irc_escape(self.organization_name) + ")-" + self.channel_id[:5]
        else:
            return "#" + irc_escape(self.channel_name) + "(" + irc_escape(self.organization_name) + ")"

    def get_member_from_account_id(self, account_id):
        for member in self.members:
            if member.account_id == account_id:
                return member
        return None

    def get_member_from_nickname(self, nickname):
        for member in self.members:
            if member.nickname == nickname:
                return member
        return None

    def add_member(self, client):
        self.members.add(client)


class IRCClient(object):
    __linesep_regexp = re.compile(r"\r?\n")
    # The RFC limit for nicknames is 9 characters, but what the heck.
    __valid_nickname_regexp = re.compile(
        r"^[][\`_^{|}A-Za-z][][\`_^{|}A-Za-z0-9-]{0,50}$")

    def __init__(self, gateway, socket):
        self.gateway = gateway
        self.socket = socket
        self.nickname = None
        self.user = None
        self.realname = None
        (self.host, self.port) = socket.getpeername()
        self.__timestamp = time.time()
        self.__readbuffer = ""
        self.__writebuffer = ""
        self.__sent_ping = False
        self.__handle_command = self.__registration_handler

    def check_aliveness(self):
        now = time.time()
        if self.__timestamp + 180 < now:
            self.disconnect("ping timeout")
            return
        if not self.__sent_ping and self.__timestamp + 90 < now:
            if self.__handle_command == self.__command_handler:
                # Registered.
                self.message("PING :%s" % self.gateway.name)
                self.__sent_ping = True
            else:
                # Not registered.
                self.disconnect("ping timeout")

    def write_queue_size(self):
        return len(self.__writebuffer)

    def __parse_read_buffer(self):
        lines = self.__linesep_regexp.split(self.__readbuffer)
        self.__readbuffer = lines[-1]
        lines = lines[:-1]
        for line in lines:
            if not line:
                # Empty line. Ignore.
                continue
            x = line.split(" ", 1)
            command = x[0].upper()
            if len(x) == 1:
                arguments = []
            else:
                if len(x[1]) > 0 and x[1][0] == ":":
                    arguments = [x[1][1:]]
                else:
                    y = string.split(x[1], " :", 1)
                    arguments = string.split(y[0])
                    if len(y) == 2:
                        arguments.append(y[1])
            self.__handle_command(command, arguments)

    def __registration_handler(self, command, arguments):
        gateway = self.gateway
        if command == "NICK":
            self.nickname = gateway.flow_email  # override user provided nickname
        elif command == "USER":
            self.user = gateway.flow_email
            self.realname = ""
        elif command == "QUIT":
            self.disconnect("Client quit")
            return
        if self.nickname and self.user:
            self.reply("001 %s :Hi, welcome to Flow" % self.nickname)
            self.reply("002 %s :Your host is %s, running version irc-flow-gateway-%s"
                       % (self.nickname, gateway.name, VERSION))
            self.send_lusers()
            self.send_motd()
            self.send_nick_data()
            self.send_channels_data()
            self.__handle_command = self.__command_handler

    def __command_handler(self, command, arguments):
        def away_handler():
            pass

        def ison_handler():
            pass

        def join_handler():
            pass

        def list_handler():
            if len(arguments) < 1:
                channels = gateway.channels.values()
            else:
                channels = []
                for channelname in arguments[0].split(","):
                    channel = gateway.get_channel_from_irc_name(channelname)
                    if channel:
                        channels.append(channel)
            channels.sort(key=lambda x: x.name)
            for channel in channels:
                self.reply("322 %s %s %d :%s"
                           % (self.nickname, channel.get_irc_name(),
                              len(channel.members), channel.topic))
            self.reply("323 %s :End of LIST" % self.nickname)

        def lusers_handler():
            self.send_lusers()

        def mode_handler():
            pass

        def motd_handler():
            self.send_motd()

        def nick_handler():
            pass

        def notice_and_privmsg_handler():
            if len(arguments) == 0:
                self.reply("411 %s :No recipient given (%s)"
                           % (self.nickname, command))
                return
            if len(arguments) == 1:
                self.reply("412 %s :No text to send" % self.nickname)
                return
            targetname = arguments[0]
            message = arguments[1]
            channel = gateway.get_channel_from_irc_name(targetname)
            if channel:
                gateway.transmit_message_to_channel(channel, message)
            else:
                member = gateway.get_member(targetname)
                if member and member.account_id != self.gateway.flow_account_id:
                    gateway.transmit_message_to_member(member, message)
                else:
                    self.reply("401 %s %s :No such nick/channel"
                               % (self.nickname, targetname))

        def part_handler():
            pass

        def ping_handler():
            if len(arguments) < 1:
                self.reply("409 %s :No origin specified" % self.nickname)
                return
            self.reply("PONG %s :%s" % (gateway.name, arguments[0]))

        def pong_handler():
            pass

        def quit_handler():
            if len(arguments) < 1:
                quitmsg = self.nickname
            else:
                quitmsg = arguments[0]
            self.disconnect(quitmsg)

        def topic_handler():
            pass

        def who_handler():
            if len(arguments) < 1:
                return
            targetname = arguments[0]
            channel = gateway.get_channel_from_irc_name(targetname)
            if channel:
                for member in channel.members:
                    self.reply("352 %s %s %s %s %s %s H :0 %s"
                               % (self.nickname, targetname, member.user,
                                  member.host, gateway.name, member.nickname,
                                  member.realname))
                self.reply("315 %s %s :End of WHO list"
                           % (self.nickname, targetname))

        def whois_handler():
            if len(arguments) < 1:
                return
            username = arguments[0]
            user = gateway.get_member(username)
            if user:
                self.reply("311 %s %s %s %s * :%s"
                           % (self.nickname, user.nickname, user.user,
                              user.host, user.realname))
                self.reply("312 %s %s %s :%s"
                           % (self.nickname, user.nickname, gateway.name,
                              gateway.name))
                self.reply("318 %s %s :End of WHOIS list"
                           % (self.nickname, user.nickname))
            else:
                self.reply("401 %s %s :No such nick"
                           % (self.nickname, username))

        handler_table = {
            "AWAY": away_handler,
            "ISON": ison_handler,
            "JOIN": join_handler,
            "LIST": list_handler,
            "LUSERS": lusers_handler,
            "MODE": mode_handler,
            "MOTD": motd_handler,
            "NICK": nick_handler,
            "NOTICE": notice_and_privmsg_handler,
            "PART": part_handler,
            "PING": ping_handler,
            "PONG": pong_handler,
            "PRIVMSG": notice_and_privmsg_handler,
            "QUIT": quit_handler,
            "TOPIC": topic_handler,
            "WHO": who_handler,
            "WHOIS": whois_handler,
        }
        gateway = self.gateway
        try:
            handler_table[command]()
        except KeyError:
            self.reply("421 %s %s :Unknown command" % (self.nickname, command))

    def socket_readable_notification(self):
        try:
            data = self.socket.recv(2 ** 10)
            self.gateway.print_debug(
                "[%s:%d] -> %r" % (self.host, self.port, data))
            quitmsg = "EOT"
        except socket.error as x:
            data = ""
            quitmsg = x
        if data:
            self.__readbuffer += data
            self.__parse_read_buffer()
            self.__timestamp = time.time()
            self.__sent_ping = False
        else:
            self.disconnect(quitmsg)

    def socket_writable_notification(self):
        try:
            sent = self.socket.send(self.__writebuffer)
            self.gateway.print_debug(
                "[%s:%d] <- %r" % (
                    self.host, self.port, self.__writebuffer[:sent]))
            self.__writebuffer = self.__writebuffer[sent:]
        except socket.error as x:
            self.disconnect(x)

    def disconnect(self, quitmsg):
        self.message("ERROR :%s" % quitmsg)
        self.gateway.print_info(
            "Disconnected connection from %s:%s (%s)." % (
                self.host, self.port, quitmsg))
        self.socket.close()
        self.gateway.remove_client(self)

    def message(self, msg):
        self.__writebuffer += msg + "\r\n"

    def reply(self, msg):
        self.message(":%s %s" % (self.gateway.name, msg))

    def send_lusers(self):
        self.reply("251 %s :There are %d users and 0 services on 1 gateway"
                   % (self.nickname, len(self.gateway.clients)))

    def send_motd(self):
        self.reply("422 %s :MOTD File is missing" % self.nickname)

    def send_channel_messages(self, channel):
        messages = self.gateway.flow_service.EnumerateMessages(
            self.gateway.flow_sid, channel.organization_id, channel.channel_id)
        for message in reversed(messages):
            member = channel.get_member_from_account_id(
                message["SenderAccountID"])
            if member:
                message_text = message["Text"]
                if self.gateway.show_timestamps:
                    message_timestamp = get_message_timestamp_string(
                        message["CreationTime"])
                    message_text = message_timestamp + " " + message_text
                self.message(":%s!%s@%s PRIVMSG %s :%s" %
                             (member.nickname, member.user, member.host, channel.get_irc_name(), message_text))

    def send_channel_join_commands(self, channel):
        # Current user JOIN command
        self.message(":%s!%s@%s JOIN :%s" %
                     (self.nickname, self.user, self.host, channel.get_irc_name()))
        # Then, JOIN for the remaining members
        for member in channel.members:
            if member.account_id != self.gateway.flow_account_id:
                self.message(":%s!%s@%s JOIN :%s" %
                             (member.nickname, member.user, member.host, channel.get_irc_name()))

    def send_nick_data(self):
        self.message(":%s!%s@%s NICK :%s" %
                     (self.nickname, self.user, self.host, self.nickname))

    def send_channels_data(self):
        for channel in self.gateway.channels.values():
            self.send_channel_join_commands(channel)
            self.send_channel_messages(channel)


class IRCFlowGateway(object):

    def __init__(self, options):
        self.ports = options.ports
        self.verbose = options.verbose
        self.debug = options.debug
        self.show_timestamps = options.show_timestamps

        gateway_name_limit = 63  # From the RFC.
        self.name = socket.getfqdn()[:gateway_name_limit]

        self.channels = {}  # ChannelID --> Channel instance.
        self.clients = {}  # Socket --> IRCClient instance.
        self.organizations = {}  # OrgID --> Organization Name
        self.pending_channels = {}  # ChannelID --> Channel instance

        if options.daemon:
            self.daemonize()

        self.initialize_flow_service(options)

    def terminate(self):
        self.set_listen_to_events(False)
        self.flow_service.Terminate()

    def set_listen_to_events(self, value=True):
        self.listen_to_events = value

    def get_member(self, nickname):
        for channel in self.channels.values():
            for member in channel.members:
                if member.nickname == nickname:
                    return member
        return None

    def get_oid_from_member(self, member):
        """Returns an OrgID that a member shares with the current flow account"""
        for channel in self.channels.values():
            for channel_member in channel.members:
                if member == channel_member:
                    return channel.organization_id
        return ""

    def transmit_message_to_channel(self, channel, message_text):
        try:
            self.flow_service.SendMessage(
                self.flow_sid, channel.organization_id, channel.channel_id, message_text)
        except:
            pass

    def transmit_message_to_member(self, member, message_text):
        try:
            oid = self.get_oid_from_member(member)
            if oid:
                direct_conversation_cid = self.flow_service.NewDirectConversation(
                    self.flow_sid, oid, member.account_id)
                self.flow_service.SendMessage(
                    self.flow_sid, oid, direct_conversation_cid, message_text)
                direct_conversation_channel = Channel(
                    self, direct_conversation_cid, "", oid, self.organizations[oid], True, True)
                member1 = ChannelMember(irc_escape(self.flow_email.encode(
                    'ascii')), self.flow_account_id, "", "", "")
                member2 = ChannelMember(irc_escape(
                    member.nickname), member.account_id, "", "", "")
                direct_conversation_channel.add_member(member1)
                direct_conversation_channel.add_member(member2)
                self.add_channel(direct_conversation_channel)
        except:
            pass

    def get_channel(self, channel_id):
        try:
            return self.channels[channel_id]
        except:
            return None

    def get_channel_from_irc_name(self, channel_irc_name):
        for channel in self.channels.values():
            if channel.get_irc_name() == channel_irc_name:
                return channel
        return None

    def get_orgs_and_channels(self):
        orgs = self.flow_service.EnumerateOrgs(self.flow_sid)
        for org in orgs:
            oid = org["ID"]
            self.organizations[oid] = org["Name"]
            channels = self.flow_service.EnumerateChannels(self.flow_sid, oid)
            for channel in channels:
                direct_channel = channel["Purpose"] == "direct message"
                irc_channel = Channel(self, channel["ID"], channel[
                                      "Name"], oid, org["Name"], direct_channel)
                self.add_channel(irc_channel)
                self.get_channel_members(irc_channel)

    def start_listener(self):
        self.event_queue = Queue.Queue()
        self.set_listen_to_events()
        self.listener_thread = threading.Thread(
            target=self.event_listener_loop,
            args=(self.flow_service, self.flow_sid, self.event_queue)
        )
        self.listener_thread.start()

    def initialize_flow_service(self, options):
        self.flow_initialized = False
        try:
            self.flow_email = options.flow_email
            self.flow_service = Flow(options.flow_flowappglue, options.debug)
            self.flow_service.Config(
                options.flow_server,
                options.flow_port,
                options.flow_db,
                options.flow_schema)
            self.flow_sid = self.flow_service.NewSession(
                self.flow_email, options.flow_uri)
            self.flow_service.StartUp(self.flow_sid)
            self.get_orgs_and_channels()
            self.start_listener()
            self.flow_initialized = True
        except Flow.FlowError as e:
            self.print_error("Flow Initialization: '%s'" % str(e))

    def daemonize(self):
        try:
            pid = os.fork()
            if pid > 0:
                sys.exit(0)
        except OSError:
            sys.exit(1)
        os.setsid()
        try:
            pid = os.fork()
            if pid > 0:
                self.print_info("PID: %d" % pid)
                sys.exit(0)
        except OSError:
            sys.exit(1)
        os.chdir("/")
        os.umask(0)
        dev_null = open("/dev/null", "r+")
        os.dup2(dev_null.fileno(), sys.stdout.fileno())
        os.dup2(dev_null.fileno(), sys.stderr.fileno())
        os.dup2(dev_null.fileno(), sys.stdin.fileno())

    def add_channel(self, channel):
        self.channels[channel.channel_id] = channel

    def print_info(self, msg):
        if self.verbose:
            print(msg)
            sys.stdout.flush()

    def print_debug(self, msg):
        if self.debug:
            print(msg)
            sys.stdout.flush()

    def print_error(self, msg):
        sys.stderr.write("%s\n" % msg)

    def remove_client(self, client):
        del self.clients[client.socket]

    def notify_clients(self, irc_msg):
        for client in self.clients.values():
            client.message(irc_msg)

    def get_channel_members(self, channel):
        members = self.flow_service.EnumerateChannelMembers(
            self.flow_sid, channel.channel_id)
        for member in members:
            account_id = member["AccountID"]
            account_email = member["EmailAddress"]
            if account_email == self.flow_email:
                self.flow_account_id = account_id
            channel_member = ChannelMember(irc_escape(
                account_email.encode('ascii')), account_id, "", "", "")
            channel.add_member(channel_member)

    def org_notification(self, organizations_data):
        for org in organizations_data:
            oid = org["ID"]
            organization_name = org["Name"]
            if not oid or not organization_name:
                continue
            self.organizations[oid] = organization_name

    def channel_notification(self, channels_data):
        for channel_data in channels_data:
            oid = channel_data["OrgID"]
            channel_id = channel_data["ID"]
            if not oid or not channel_id:
                continue
            channel = self.get_channel(channel_id)
            if channel:  # existing channel?
                continue
            if oid not in self.organizations:
                continue
            organization_name = self.organizations[oid]
            new_channel = Channel(self, channel_id, "", oid, organization_name)
            self.pending_channels[channel_id] = new_channel

    def process_channel_message(self, message):
        channel_id = message["ID"]
        channel_name = message["Name"]
        direct_channel = message["Purpose"] == "direct message"
        if not channel_id or (not channel_name and not direct_channel):
            return
        channel = self.pending_channels[channel_id]
        if not channel:
            return
        # Update the channel name
        if direct_channel:
            channel.direct_channel = True
        else:
            channel.set_name(channel_name)

        self.get_channel_members(channel)

        self.add_channel(channel)
        del self.pending_channels[channel_id]

        for client in self.clients.values():
            client.send_channel_join_commands(channel)

    def process_regular_message(self, message):
        sender_account_id = message["SenderAccountID"]
        channel_id = message["ChannelID"]
        message_text = message["Text"]
        if not sender_account_id or not channel_id or not message_text:
            return
        channel = self.get_channel(channel_id)
        if not channel:
            return
        sender_member = channel.get_member_from_account_id(sender_account_id)
        if not sender_member:
            return
        if self.show_timestamps:
            message_timestamp = get_message_timestamp_string(
                message["CreationTime"])
            message_text = message_timestamp + " " + message_text
        self.notify_clients(":%s!%s@%s PRIVMSG %s :%s" %
                            (sender_member.nickname, sender_member.user, sender_member.host, channel.get_irc_name(), message_text))

    def message_notification(self, messages_data):
        channel_messages = messages_data["ChannelMessages"]
        if channel_messages:
            for message in channel_messages:
                self.process_channel_message(message)

        regular_messages = messages_data["RegularMessages"]
        if regular_messages:
            for message in regular_messages:
                self.process_regular_message(message)

    def channel_member_notification(self, channel_ids):
        for channel_id in channel_ids:
            channel = self.get_channel(channel_id)
            if not channel:
                continue
            members = self.flow_service.EnumerateChannelMembers(
                self.flow_sid, channel_id)
            for member in members:
                channel_member = channel.get_member_from_nickname(
                    member["EmailAddress"])
                if not channel_member:
                    channel_member = ChannelMember(
                        irc_escape(member["EmailAddress"].encode('ascii')), member["AccountID"], "", "", "")
                    channel.add_member(channel_member)
                    self.notify_clients(":%s!%s@%s JOIN :%s" %
                                        (channel_member.nickname, channel_member.user, channel_member.host, channel.get_irc_name()))

    __supported_notifications = [
        "org", "channel", "message", "channel-member-event"]

    def process_notifications_queue(self):
        event_handler = {
            "org": self.org_notification,
            "channel": self.channel_notification,
            "message": self.message_notification,
            "channel-member-event": self.channel_member_notification,
        }
        while not self.event_queue.empty():
            event = self.event_queue.get()
            try:
                event_handler[event["Type"]](event["Data"])
            except KeyError:
                self.print_debug(
                    "Notification of type '%s' not supported." % event["Type"])

    def event_listener_loop(self, flow, sid, event_queue):
        while self.listen_to_events:
            try:
                change = flow.WaitForNotification(sid)
                if change and (change["Type"] in self.__supported_notifications):
                    event_queue.put(change)
            except Flow.FlowError:
                pass

    def start(self):
        if not self.flow_initialized:
            self.terminate()
            return
        gatewaysockets = []
        for port in self.ports:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind(("localhost", port))  # Listen to local connections only
            except socket.error as e:
                self.print_error("Could not bind port %s: %s." % (port, e))
                sys.exit(1)
            s.listen(5)
            gatewaysockets.append(s)
            del s
            self.print_info("Listening on port %d." % port)
        last_aliveness_check = time.time()
        while True:
            self.process_notifications_queue()
            (iwtd, owtd, ewtd) = select.select(
                gatewaysockets + [x.socket for x in self.clients.values()],
                [x.socket for x in self.clients.values()
                 if x.write_queue_size() > 0],
                [], 0)
            for x in iwtd:
                if x in self.clients:
                    self.clients[x].socket_readable_notification()
                else:
                    (conn, addr) = x.accept()
                    try:
                        self.clients[conn] = IRCClient(self, conn)
                        self.print_info("Accepted connection from %s:%s." % (
                            addr[0], addr[1]))
                    except socket.error as e:
                        try:
                            conn.close()
                        except:
                            pass
            for x in owtd:
                if x in self.clients:  # client may have been disconnected
                    self.clients[x].socket_writable_notification()
            now = time.time()
            if last_aliveness_check + 10 < now:
                for client in self.clients.values():
                    client.check_aliveness()
                last_aliveness_check = now


def main(argv):
    op = OptionParser(
        version=VERSION,
        description="irc-flow-gateway is a small IRC gateway to SpiderOak Flow (based on miniircd)")
    op.add_option(
        "-d", "--daemon",
        action="store_true",
        help="fork and become a daemon")
    op.add_option(
        "--debug",
        action="store_true",
        help="print debug messages to stdout")
    op.add_option(
        "--ports",
        metavar="X",
        help="listen to ports X (a list separated by comma or whitespace);"
             " default: 6667")
    op.add_option(
        "--verbose",
        action="store_true",
        help="be verbose (print some progress messages to stdout)")
    op.add_option(
        "--flow-flowappglue",
        metavar="X",
        help="flowappglue binary path (by default ./flowappglue)")
    op.add_option(
        "--flow-server",
        metavar="X",
        help="flow service host/ip")
    op.add_option(
        "--flow-port",
        metavar="X",
        help="flow service port")
    op.add_option(
        "--flow-db",
        metavar="X",
        help="flow db directory")
    op.add_option(
        "--flow-schema",
        metavar="X",
        help="flow schema directory")
    op.add_option(
        "--flow-email",
        metavar="X",
        help="flow account email")
    op.add_option(
        "--flow-uri",
        metavar="X",
        help="flow account gateway uri")
    op.add_option(
        "--show-timestamps",
        action="store_true",
        help="prepend timestamps on messages (format: [Y-m-d H:M:S])")

    (options, args) = op.parse_args(argv[1:])

    if not options.flow_server or \
       not options.flow_port or \
       not options.flow_db or \
       not options.flow_email or \
       not options.flow_uri:
        missing_arguments = []
        if not options.flow_server:
            missing_arguments.append("'--flow-server'")
        if not options.flow_port:
            missing_arguments.append("'--flow-port'")
        if not options.flow_db:
            missing_arguments.append("'--flow-db'")
        if not options.flow_email:
            missing_arguments.append("'--flow-email'")
        if not options.flow_uri:
            missing_arguments.append("'--flow-uri'")
        op.error("Missing arguments: %s" % ", ".join(missing_arguments))

    if not options.flow_flowappglue:
        options.flow_flowappglue = "./flowappglue"

    if options.debug:
        options.verbose = True
    if options.ports is None:
        options.ports = "6667"
    ports = []
    for port in re.split(r"[,\s]+", options.ports):
        try:
            ports.append(int(port))
        except ValueError:
            op.error("bad port: %r" % port)
    options.ports = ports
    gateway = IRCFlowGateway(options)

    def signal_handler(signal, frame):
        print(" ... terminating ...")
        gateway.terminate()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    gateway.start()


main(sys.argv)
